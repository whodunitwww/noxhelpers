local cryptmodule = {}

-- Base64URL helpers (usa crypt.base64_* disponibles)
cryptmodule.b64url_to_bytes = function(s)
    s = s:gsub("-", "+"):gsub("_", "/")
    s = s .. string.rep("=", (4 - #s % 4) % 4)
    return crypt.base64_decode(s)
end

cryptmodule.bytes_to_b64url = function(bytes)
    local b64 = crypt.base64_encode(bytes)
    return b64:gsub("%+", "-"):gsub("/", "_"):gsub("=", "")
end

-- SHA-256 puro (hex) sin usar crypt.hash
cryptmodule.sha256 = function(msg)
    local band, bor, bxor, bnot = bit32.band, bit32.bor, bit32.bxor, bit32.bnot
    local lshift, rshift = bit32.lshift, bit32.rshift
    local function rrotate(x, n)
        n = n % 32
        return bor(rshift(x, n), lshift(x, 32 - n)) % 4294967296
    end
    local function add32(a, b)
        return (a + b) % 4294967296
    end
    local function add_many(a, b, c, d, e)
        local s = (a or 0) + (b or 0) + (c or 0) + (d or 0) + (e or 0)
        return s % 4294967296
    end

    local H = {
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
    }
    local K = {
        0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
        0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
        0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
        0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
        0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
        0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
        0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
        0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2,
    }
    local function Ch(x,y,z) return bxor(band(x,y), band(bnot(x), z)) end
    local function Maj(x,y,z) return bxor(band(x,y), band(x,z), band(y,z)) end
    local function S0(x) return bxor(rrotate(x,2), rrotate(x,13), rrotate(x,22)) end
    local function S1(x) return bxor(rrotate(x,6), rrotate(x,11), rrotate(x,25)) end
    local function s0(x) return bxor(rrotate(x,7), rrotate(x,18), rshift(x,3)) end
    local function s1(x) return bxor(rrotate(x,17), rrotate(x,19), rshift(x,10)) end

    local bytes = {string.byte(msg, 1, #msg)}
    local bitLen = #bytes * 8
    bytes[#bytes + 1] = 0x80
    while ((#bytes + 8) % 64) ~= 0 do bytes[#bytes + 1] = 0 end
    local hi = math.floor(bitLen / 4294967296)
    local lo = bitLen % 4294967296
    local function append32(v)
        bytes[#bytes + 1] = math.floor(v / 16777216) % 256
        bytes[#bytes + 1] = math.floor(v / 65536) % 256
        bytes[#bytes + 1] = math.floor(v / 256) % 256
        bytes[#bytes + 1] = v % 256
    end
    append32(hi); append32(lo)

    local w = table.create(64)
    local a,b,c,d,e,f,g,h
    for i = 1, #bytes, 64 do
        for t = 0, 15 do
            local j = i + (t * 4)
            local v = bytes[j] * 16777216 + bytes[j+1] * 65536 + bytes[j+2] * 256 + bytes[j+3]
            w[t] = v
        end
        for t = 16, 63 do
            w[t] = add_many(s1(w[t-2] or 0), w[t-7] or 0, s0(w[t-15] or 0), w[t-16] or 0)
        end

        a,b,c,d,e,f,g,h = H[1],H[2],H[3],H[4],H[5],H[6],H[7],H[8]
        for t = 0, 63 do
            local T1 = add_many(h, S1(e), Ch(e,f,g), K[t+1], w[t])
            local T2 = add32(S0(a), Maj(a,b,c))
            h = g; g = f; f = e
            e = add32(d, T1)
            d = c; c = b; b = a
            a = add32(T1, T2)
        end
        H[1] = add32(H[1], a); H[2] = add32(H[2], b); H[3] = add32(H[3], c); H[4] = add32(H[4], d)
        H[5] = add32(H[5], e); H[6] = add32(H[6], f); H[7] = add32(H[7], g); H[8] = add32(H[8], h)
    end
    return string.format("%08x%08x%08x%08x%08x%08x%08x%08x", H[1],H[2],H[3],H[4],H[5],H[6],H[7],H[8])
end

cryptmodule.hex_to_bytes = function(hex)
    local out = table.create(#hex // 2)
    for i = 1, #hex, 2 do
        local byte = tonumber(hex:sub(i, i + 1), 16)
        out[#out + 1] = string.char(byte)
    end
    return table.concat(out)
end

return cryptmodule