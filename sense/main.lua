local a=loadstring(game:HttpGet("https://raw.githubusercontent.com/whodunitwww/noxhelpers/refs/heads/main/sense/maid.lua"))()local b=loadstring(game:HttpGet("https://raw.githubusercontent.com/whodunitwww/noxhelpers/refs/heads/main/sense/signal.lua"))()local c=game:GetService("RunService")local d=game:GetService("Players")local e=game:GetService("Workspace")local f=d.LocalPlayer;local g=e.CurrentCamera;local h=g.ViewportSize;local i=Instance.new("Folder",gethui and gethui()or game:GetService("CoreGui"))local j=math.floor;local k=math.round;local l=math.atan2;local m=math.sin;local n=math.cos;local o=table.clear;local p=table.unpack;local q=table.find;local r=g.WorldToViewportPoint;local s=e.IsA;local t=e.GetPivot;local u=e.FindFirstChild;local v=e.FindFirstChildOfClass;local w=e.GetChildren;local x=CFrame.identity.ToOrientation;local y=CFrame.identity.PointToObjectSpace;local z=Color3.new().Lerp;local A=Vector2.zero.Min;local B=Vector2.zero.Max;local C=Vector2.zero.Lerp;local D=Vector3.zero.Min;local E=Vector3.zero.Max;local F=Vector2.new(5,0)local G=Vector2.new(3,0)local H=Vector2.new(0,1)local I=Vector2.new(0,2)local J=Vector2.new(0,2)local K={Vector3.new(-1,-1,-1),Vector3.new(-1,1,-1),Vector3.new(-1,1,1),Vector3.new(-1,-1,1),Vector3.new(1,-1,-1),Vector3.new(1,1,-1),Vector3.new(1,1,1),Vector3.new(1,-1,1)}local function L(M)return M=="Head"or M:find("Torso")or M:find("Leg")or M:find("Arm")end;local function N(O)if not O or#O==0 then return CFrame.new(),Vector3.new(4,4,4)end;local P,Q;for R=1,#O do local S=O[R]if S and S.Parent then local T,U=S.CFrame,S.Size;P=D(P or T.Position,(T-U*0.5).Position)Q=E(Q or T.Position,(T+U*0.5).Position)end end;if not P or not Q then return CFrame.new(),Vector3.new(4,4,4)end;local V=(P+Q)*0.5;local W=Vector3.new(V.X,V.Y,Q.Z)return CFrame.new(V,W),Q-P end;local function X(Y)local Z,_=r(g,Y)return Vector2.new(Z.X,Z.Y),_,Z.Z end;local function a0(T,U)local a1={}for R=1,#K do a1[R]=X((T+U*0.5*K[R]).Position)end;local P=A(h,p(a1))local Q=B(Vector2.zero,p(a1))return{corners=a1,topLeft=Vector2.new(j(P.X),j(P.Y)),topRight=Vector2.new(j(Q.X),j(P.Y)),bottomLeft=Vector2.new(j(P.X),j(Q.Y)),bottomRight=Vector2.new(j(Q.X),j(Q.Y))}end;local function a2(a3,a4)local a5,a6=n(a4),m(a4)return Vector2.new(a5*a3.X-a6*a3.Y,a6*a3.X+a5*a3.Y)end;local a7={}a7.__index=a7;function a7.new(a8,a9)local self=setmetatable({},a7)self.player=assert(a8,"Missing argument #1 (Player expected)")self.interface=assert(a9,"Missing argument #2 (table expected)")self.maid=a.new()self:Construct()return self end;function a7:Construct()self.charCache={}self.childCount=0;self.bin={}self.drawings={box3d={{self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false})},{self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false})},{self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false})},{self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false})}},visible={tracerOutline=self:create("Line",{Thickness=3,Visible=false}),tracer=self:create("Line",{Thickness=1,Visible=false}),boxFill=self:create("Square",{Filled=true,Visible=false}),boxOutline=self:create("Square",{Thickness=3,Visible=false}),box=self:create("Square",{Thickness=1,Visible=false}),healthBarOutline=self:create("Line",{Thickness=3,Visible=false}),healthBar=self:create("Line",{Thickness=1,Visible=false}),healthText=self:create("Text",{Center=true,Visible=false}),name=self:create("Text",{Text=self.player.Name,Center=true,Visible=false}),distance=self:create("Text",{Center=true,Visible=false}),weapon=self:create("Text",{Center=true,Visible=false})},hidden={arrowOutline=self:create("Triangle",{Thickness=3,Visible=false}),arrow=self:create("Triangle",{Filled=true,Visible=false})}}self.renderConnection=c.Heartbeat:Connect(function(aa)self:Update(aa)self:Render(aa)end)self.maid:AddTask(self.renderConnection)end;function a7:create(ab,ac)local ad=Drawing.new(ab)for ae,af in next,ac do ad[ae]=af end;self.bin[#self.bin+1]=ad;self.maid:AddTask(ad)return ad end;function a7:Destruct()if self.drawings then for ag,ah in pairs(self.drawings)do if type(ah)=="table"then for ag,ad in pairs(ah)do if type(ad)=="table"then for ag,ai in pairs(ad)do if ai.Visible~=nil then ai.Visible=false end end elseif ad.Visible~=nil then ad.Visible=false end end end end end;self.maid:Cleanup()o(self)end;function a7:Update()local a9=self.interface;self.options=a9.teamSettings[a9.isFriendly(self.player)and"friendly"or"enemy"]self.character=a9.getCharacter(self.player)self.health,self.maxHealth=a9.getHealth(self.character)self.weapon=a9.getWeapon(self.player)self.enabled=self.options.enabled and self.character and not(#a9.whitelist>0 and not q(a9.whitelist,self.player.UserId))local aj=self.enabled and u(self.character,"Head")if not aj then return end;local ag,ak,al=X(aj.Position)self.onScreen=ak;self.distance=al;if a9.sharedSettings.limitDistance and al>a9.sharedSettings.maxDistance then self.onScreen=false end;if self.onScreen then local am=self.charCache;local an=w(self.character)if not am[1]or self.childCount~=#an then o(am)for R=1,#an do local S=an[R]if s(S,"BasePart")and L(S.Name)then am[#am+1]=S end end;self.childCount=#an end;self.corners=a0(N(am))elseif self.options.offScreenArrow then local ag,ao,ap=x(g.CFrame)local aq=CFrame.Angles(0,ao,ap)+g.CFrame.Position;local ar=y(aq,aj.Position)local as=l(ar.Z,ar.X)self.direction=Vector2.new(n(as),m(as))end end;function a7:Render()local ak=self.onScreen or false;local at=self.enabled or false;local au=self.drawings.visible;local av=self.drawings.hidden;local aw=self.drawings.box3d;local a9=self.interface;local ax=self.options;local a1=self.corners;au.box.Visible=at and ak and ax.box;au.boxOutline.Visible=au.box.Visible and ax.boxOutline;if au.box.Visible then local ay=au.box;ay.Position=a1.topLeft;ay.Size=a1.bottomRight-a1.topLeft;ay.Color=ax.boxColor[1]ay.Transparency=ax.boxColor[2]local az=au.boxOutline;az.Position=ay.Position;az.Size=ay.Size;az.Color=ax.boxOutlineColor[1]az.Transparency=ax.boxOutlineColor[2]end;au.boxFill.Visible=at and ak and ax.boxFill;if au.boxFill.Visible then local aA=au.boxFill;aA.Position=a1.topLeft;aA.Size=a1.bottomRight-a1.topLeft;aA.Color=ax.boxFillColor[1]aA.Transparency=ax.boxFillColor[2]end;au.healthBar.Visible=at and ak and ax.healthBar;au.healthBarOutline.Visible=au.healthBar.Visible and ax.healthBarOutline;if au.healthBar.Visible then local aB=a1.topLeft-F;local aC=a1.bottomLeft-F;local aD=au.healthBar;aD.To=aC;aD.From=C(aC,aB,self.health/self.maxHealth)aD.Color=z(ax.dyingColor,ax.healthyColor,self.health/self.maxHealth)local aE=au.healthBarOutline;aE.To=aC+H;aE.From=aB-H;aE.Color=ax.healthBarOutlineColor[1]aE.Transparency=ax.healthBarOutlineColor[2]end;au.healthText.Visible=at and ak and ax.healthText;if au.healthText.Visible then local aB=a1.topLeft-F;local aC=a1.bottomLeft-F;local aF=au.healthText;aF.Text=k(self.health).."hp"aF.Size=a9.sharedSettings.textSize;aF.Font=a9.sharedSettings.textFont;aF.Color=ax.healthTextColor[1]aF.Transparency=ax.healthTextColor[2]aF.Outline=ax.healthTextOutline;aF.OutlineColor=ax.healthTextOutlineColor;local aG=0;if self.health and self.maxHealth and self.maxHealth>0 then aG=math.max(0,math.min(1,self.health/self.maxHealth))end;aF.Position=C(aC,aB,aG)-Vector2.new(aF.TextBounds.X/2,aF.TextBounds.Y/2)-G end;au.name.Visible=at and ak and ax.name;if au.name.Visible then local M=au.name;M.Size=a9.sharedSettings.textSize;M.Font=a9.sharedSettings.textFont;M.Color=ax.nameColor[1]M.Transparency=ax.nameColor[2]M.Outline=ax.nameOutline;M.OutlineColor=ax.nameOutlineColor;M.Position=(a1.topLeft+a1.topRight)*0.5-Vector2.yAxis*M.TextBounds.Y-I end;au.distance.Visible=at and ak and self.distance and ax.distance;if au.distance.Visible then local aH=au.distance;aH.Text=k(self.distance).." studs"aH.Size=a9.sharedSettings.textSize;aH.Font=a9.sharedSettings.textFont;aH.Color=ax.distanceColor[1]aH.Transparency=ax.distanceColor[2]aH.Outline=ax.distanceOutline;aH.OutlineColor=ax.distanceOutlineColor;aH.Position=(a1.bottomLeft+a1.bottomRight)*0.5+J end;au.weapon.Visible=at and ak and ax.weapon;if au.weapon.Visible then local aI=au.weapon;aI.Text=self.weapon;aI.Size=a9.sharedSettings.textSize;aI.Font=a9.sharedSettings.textFont;aI.Color=ax.weaponColor[1]aI.Transparency=ax.weaponColor[2]aI.Outline=ax.weaponOutline;aI.OutlineColor=ax.weaponOutlineColor;aI.Position=(a1.bottomLeft+a1.bottomRight)*0.5+(au.distance.Visible and J+Vector2.yAxis*au.distance.TextBounds.Y or Vector2.zero)end;au.tracer.Visible=at and ak and ax.tracer;au.tracerOutline.Visible=au.tracer.Visible and ax.tracerOutline;if au.tracer.Visible then local aJ=au.tracer;aJ.Color=ax.tracerColor[1]aJ.Transparency=ax.tracerColor[2]aJ.To=(a1.bottomLeft+a1.bottomRight)*0.5;aJ.From=ax.tracerOrigin=="Middle"and h*0.5 or ax.tracerOrigin=="Top"and h*Vector2.new(0.5,0)or ax.tracerOrigin=="Bottom"and h*Vector2.new(0.5,1)local aK=au.tracerOutline;aK.Color=ax.tracerOutlineColor[1]aK.Transparency=ax.tracerOutlineColor[2]aK.To=aJ.To;aK.From=aJ.From end;av.arrow.Visible=at and not ak and ax.offScreenArrow;av.arrowOutline.Visible=av.arrow.Visible and ax.offScreenArrowOutline;if av.arrow.Visible then local aL=av.arrow;aL.PointA=A(B(h*0.5+self.direction*ax.offScreenArrowRadius,Vector2.one*25),h-Vector2.one*25)aL.PointB=aL.PointA-a2(self.direction,0.45)*ax.offScreenArrowSize;aL.PointC=aL.PointA-a2(self.direction,-0.45)*ax.offScreenArrowSize;aL.Color=ax.offScreenArrowColor[1]aL.Transparency=ax.offScreenArrowColor[2]local aM=av.arrowOutline;aM.PointA=aL.PointA;aM.PointB=aL.PointB;aM.PointC=aL.PointC;aM.Color=ax.offScreenArrowOutlineColor[1]aM.Transparency=ax.offScreenArrowOutlineColor[2]end;local aN=at and ak and ax.box3d;for R=1,#aw do local aO=aw[R]for aP=1,#aO do local ai=aO[aP]ai.Visible=aN;ai.Color=ax.box3dColor[1]ai.Transparency=ax.box3dColor[2]end;if aN then local aQ=aO[1]aQ.From=a1.corners[R]aQ.To=a1.corners[R==4 and 1 or R+1]local aR=aO[2]aR.From=a1.corners[R==4 and 1 or R+1]aR.To=a1.corners[R==4 and 5 or R+5]local aS=aO[3]aS.From=a1.corners[R==4 and 5 or R+5]aS.To=a1.corners[R==4 and 8 or R+4]end end end;local aT={}aT.__index=aT;function aT.new(a8,a9)local self=setmetatable({},aT)self.player=assert(a8,"Missing argument #1 (Player expected)")self.interface=assert(a9,"Missing argument #2 (table expected)")self.maid=a.new()self:Construct()return self end;function aT:Construct()self.highlight=Instance.new("Highlight",i)self.maid:AddTask(self.highlight)self.updateConnection=c.Heartbeat:Connect(function()self:Update()end)self.maid:AddTask(self.updateConnection)end;function aT:Destruct()self.maid:Cleanup()o(self)end;function aT:Update()local aU=self.highlight;local a9=self.interface;local aV=a9.getCharacter(self.player)local ax=a9.teamSettings[a9.isFriendly(self.player)and"friendly"or"enemy"]local at=ax.enabled and aV and not(#a9.whitelist>0 and not q(a9.whitelist,self.player.UserId))aU.Enabled=at and ax.chams;if aU.Enabled then aU.DepthMode=ax.chamsVisibleOnly and Enum.HighlightDepthMode.Occluded or Enum.HighlightDepthMode.AlwaysOnTop;aU.Adornee=aV;aU.FillColor=ax.chamsFillColor[1]aU.FillTransparency=ax.chamsFillColor[2]aU.OutlineColor=ax.chamsOutlineColor[1]aU.OutlineTransparency=ax.chamsOutlineColor[2]end end;local aW={}aW.__index=aW;function aW.new(aX,a9,aY)local self=setmetatable({},aW)self.instance=assert(aX,"Missing argument #1 (Instance expected)")self.interface=assert(a9,"Missing argument #2 (table expected)")self.customOptions=aY or{}self.maid=a.new()self:Construct()return self end;function aW:Construct()self.charCache={}self.childCount=0;self.bin={}self.drawings={box3d={},visible={tracerOutline=self:create("Line",{Thickness=3,Visible=false}),tracer=self:create("Line",{Thickness=1,Visible=false}),boxFill=self:create("Square",{Filled=true,Visible=false}),boxOutline=self:create("Square",{Thickness=3,Visible=false}),box=self:create("Square",{Thickness=1,Visible=false}),healthBarOutline=self:create("Line",{Thickness=3,Visible=false}),healthBar=self:create("Line",{Thickness=1,Visible=false}),healthText=self:create("Text",{Center=true,Visible=false}),name=self:create("Text",{Text=self.instance.Name,Center=true,Visible=false}),distance=self:create("Text",{Center=true,Visible=false}),customText=self:create("Text",{Center=true,Visible=false})},hidden={arrowOutline=self:create("Triangle",{Thickness=3,Visible=false}),arrow=self:create("Triangle",{Filled=true,Visible=false})}}if self.customOptions.box3d then for R=1,4 do self.drawings.box3d[R]={self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false}),self:create("Line",{Thickness=1,Visible=false})}end end;self.renderConnection=c.Heartbeat:Connect(function(aa)self:Update(aa)self:Render(aa)end)self.maid:AddTask(self.renderConnection)end;function aW:create(ab,ac)local ad=Drawing.new(ab)for ae,af in next,ac do ad[ae]=af end;self.bin[#self.bin+1]=ad;self.maid:AddTask(ad)return ad end;function aW:Destruct()if self.drawings then for ag,ah in pairs(self.drawings)do if type(ah)=="table"then for ag,ad in pairs(ah)do if type(ad)=="table"then for ag,ai in pairs(ad)do if ai.Visible~=nil then ai.Visible=false end end elseif ad.Visible~=nil then ad.Visible=false end end end end end;if self.interface and self.interface._instanceCache then local am=self.interface._instanceCache;if am[self.instance]then am[self.instance]=nil end end;self.maid:Cleanup()o(self)end;function aW:Update()if not self.instance or not self.instance.Parent then return self:Destruct()end;local a9=self.interface;local ax=a9.instanceSettings or a9.teamSettings.enemy;for aZ,af in pairs(self.customOptions)do ax[aZ]=af end;self.options=ax;self.enabled=ax.enabled;local a_=self.instance:FindFirstChild("HumanoidRootPart")or self.instance:FindFirstChild("Primary")or self.instance:FindFirstChildOfClass("BasePart")if not a_ then return end;local ag,ak,al=X(a_.Position)self.onScreen=ak;self.distance=al;if a9.sharedSettings.limitDistance and al>a9.sharedSettings.maxDistance then self.onScreen=false end;if self.onScreen then local am=self.charCache;local an=w(self.instance)if not am[1]or self.childCount~=#an then o(am)for R=1,#an do local S=an[R]if s(S,"BasePart")then am[#am+1]=S end end;self.childCount=#an end;self.corners=a0(N(am))elseif ax.offScreenArrow then local ag,ao,ap=x(g.CFrame)local aq=CFrame.Angles(0,ao,ap)+g.CFrame.Position;local ar=y(aq,a_.Position)local as=l(ar.Z,ar.X)self.direction=Vector2.new(n(as),m(as))end;if self.interface.getHealth then self.health,self.maxHealth=self.interface.getHealth(self.instance)else local b0=self.instance:FindFirstChildOfClass("Humanoid")if b0 then self.health=b0.Health;self.maxHealth=b0.MaxHealth else self.health=100;self.maxHealth=100 end end end;function aW:Render()if not self.drawings or not self.drawings.visible then return end;local ak=self.onScreen or false;local at=self.enabled or false;local au=self.drawings.visible;local av=self.drawings.hidden;local aw=self.drawings.box3d;local a9=self.interface;local ax=self.options;local a1=self.corners;if not a1 then for ag,ad in pairs(au)do ad.Visible=false end;for ag,ad in pairs(av)do ad.Visible=false end;for ag,aO in pairs(aw)do for ag,ai in pairs(aO)do ai.Visible=false end end;return end;au.box.Visible=at and ak and ax.box;au.boxOutline.Visible=au.box.Visible and ax.boxOutline;if au.box.Visible then local ay=au.box;ay.Position=a1.topLeft;ay.Size=a1.bottomRight-a1.topLeft;ay.Color=ax.boxColor[1]ay.Transparency=ax.boxColor[2]local az=au.boxOutline;az.Position=ay.Position;az.Size=ay.Size;az.Color=ax.boxOutlineColor[1]az.Transparency=ax.boxOutlineColor[2]end;au.boxFill.Visible=at and ak and ax.boxFill;if au.boxFill.Visible then local aA=au.boxFill;aA.Position=a1.topLeft;aA.Size=a1.bottomRight-a1.topLeft;aA.Color=ax.boxFillColor[1]aA.Transparency=ax.boxFillColor[2]end;au.healthBar.Visible=at and ak and ax.healthBar and self.health~=nil;au.healthBarOutline.Visible=au.healthBar.Visible and ax.healthBarOutline;if au.healthBar.Visible then local aB=a1.topLeft-F;local aC=a1.bottomLeft-F;local aG=0;if self.health and self.maxHealth and self.maxHealth>0 then aG=math.max(0,math.min(1,self.health/self.maxHealth))end;local aD=au.healthBar;aD.To=Vector2.new(aC.X,aC.Y)aD.From=C(aC,aB,aG)aD.Color=z(ax.dyingColor,ax.healthyColor,aG)if au.healthBarOutline.Visible then local aE=au.healthBarOutline;local b1=aB-H;local b2=aC+H;aE.To=b2;aE.From=b1;aE.Color=ax.healthBarOutlineColor[1]aE.Transparency=ax.healthBarOutlineColor[2]end end;au.healthText.Visible=at and ak and ax.healthText and self.health~=nil;if au.healthText.Visible then local aB=a1.topLeft-F;local aC=a1.bottomLeft-F;local aF=au.healthText;aF.Text=k(self.health).."hp"aF.Size=a9.sharedSettings.textSize;aF.Font=a9.sharedSettings.textFont;aF.Color=ax.healthTextColor[1]aF.Transparency=ax.healthTextColor[2]aF.Outline=ax.healthTextOutline;aF.OutlineColor=ax.healthTextOutlineColor;aF.Position=C(aC,aB,self.health/self.maxHealth)-aF.TextBounds*0.5-G end;au.name.Visible=at and ak and ax.name;if au.name.Visible then local M=au.name;M.Size=a9.sharedSettings.textSize;M.Font=a9.sharedSettings.textFont;M.Color=ax.nameColor[1]M.Transparency=ax.nameColor[2]M.Outline=ax.nameOutline;M.OutlineColor=ax.nameOutlineColor;M.Position=(a1.topLeft+a1.topRight)*0.5-Vector2.yAxis*M.TextBounds.Y-I end;au.distance.Visible=at and ak and self.distance and ax.distance;if au.distance.Visible then local aH=au.distance;aH.Text=k(self.distance).." studs"aH.Size=a9.sharedSettings.textSize;aH.Font=a9.sharedSettings.textFont;aH.Color=ax.distanceColor[1]aH.Transparency=ax.distanceColor[2]aH.Outline=ax.distanceOutline;aH.OutlineColor=ax.distanceOutlineColor;aH.Position=(a1.bottomLeft+a1.bottomRight)*0.5+J end;au.customText.Visible=at and ak and ax.customText;if au.customText.Visible then local b3=au.customText;b3.Text=ax.customTextValue or""b3.Size=a9.sharedSettings.textSize;b3.Font=a9.sharedSettings.textFont;b3.Color=ax.customTextColor[1]b3.Transparency=ax.customTextColor[2]b3.Outline=ax.customTextOutline;b3.OutlineColor=ax.customTextOutlineColor;b3.Position=(a1.bottomLeft+a1.bottomRight)*0.5+(au.distance.Visible and J+Vector2.yAxis*au.distance.TextBounds.Y or Vector2.zero)end;au.tracer.Visible=at and ak and ax.tracer;au.tracerOutline.Visible=au.tracer.Visible and ax.tracerOutline;if au.tracer.Visible then local aJ=au.tracer;aJ.Color=ax.tracerColor[1]aJ.Transparency=ax.tracerColor[2]aJ.To=(a1.bottomLeft+a1.bottomRight)*0.5;aJ.From=ax.tracerOrigin=="Middle"and h*0.5 or ax.tracerOrigin=="Top"and h*Vector2.new(0.5,0)or ax.tracerOrigin=="Bottom"and h*Vector2.new(0.5,1)local aK=au.tracerOutline;aK.Color=ax.tracerOutlineColor[1]aK.Transparency=ax.tracerOutlineColor[2]aK.To=aJ.To;aK.From=aJ.From end;av.arrow.Visible=at and not ak and ax.offScreenArrow;av.arrowOutline.Visible=av.arrow.Visible and ax.offScreenArrowOutline;if av.arrow.Visible then local aL=av.arrow;aL.PointA=A(B(h*0.5+self.direction*ax.offScreenArrowRadius,Vector2.one*25),h-Vector2.one*25)aL.PointB=aL.PointA-a2(self.direction,0.45)*ax.offScreenArrowSize;aL.PointC=aL.PointA-a2(self.direction,-0.45)*ax.offScreenArrowSize;aL.Color=ax.offScreenArrowColor[1]aL.Transparency=ax.offScreenArrowColor[2]local aM=av.arrowOutline;aM.PointA=aL.PointA;aM.PointB=aL.PointB;aM.PointC=aL.PointC;aM.Color=ax.offScreenArrowOutlineColor[1]aM.Transparency=ax.offScreenArrowOutlineColor[2]end;local aN=at and ak and ax.box3d;for R=1,#aw do local aO=aw[R]for aP=1,#aO do local ai=aO[aP]ai.Visible=aN;if aN then ai.Color=ax.box3dColor[1]ai.Transparency=ax.box3dColor[2]end end;if aN then local aQ=aO[1]aQ.From=a1.corners[R]aQ.To=a1.corners[R==4 and 1 or R+1]local aR=aO[2]aR.From=a1.corners[R==4 and 1 or R+1]aR.To=a1.corners[R==4 and 5 or R+5]local aS=aO[3]aS.From=a1.corners[R==4 and 5 or R+5]aS.To=a1.corners[R==4 and 8 or R+4]end end end;local b4={}b4.__index=b4;function b4.new(aX,ax)local self=setmetatable({},b4)self.instance=assert(aX,"Missing argument #1 (Instance Expected)")self.options=assert(ax,"Missing argument #2 (table expected)")self.maid=a.new()self.removedConnection=aX.AncestryChanged:Connect(function()if not aX.Parent then self:Destruct()end end)self.maid:AddTask(self.removedConnection)self:Construct()return self end;function b4:Construct()local ax=self.options;ax.enabled=ax.enabled==nil and true or ax.enabled;ax.text=ax.text or"{name}"ax.textColor=ax.textColor or{Color3.new(1,1,1),1}ax.textOutline=ax.textOutline==nil and true or ax.textOutline;ax.textOutlineColor=ax.textOutlineColor or Color3.new()ax.textSize=ax.textSize or 13;ax.textFont=ax.textFont or 2;ax.limitDistance=ax.limitDistance or false;ax.maxDistance=ax.maxDistance or 150;self.text=Drawing.new("Text")self.text.Center=true;self.maid:AddTask(self.text)self.renderConnection=c.Heartbeat:Connect(function(aa)self:Render(aa)end)self.maid:AddTask(self.renderConnection)end;function b4:Destruct()if self.text then self.text.Visible=false end;self.maid:Cleanup()local am=EspInterface._instanceCache;if am and am[self.instance]then am[self.instance]=nil end;o(self)end;function b4:Render()local aX=self.instance;if not aX or not aX.Parent then return self:Destruct()end;local b5=self.text;local ax=self.options;if not ax.enabled then b5.Visible=false;return end;local Y=t(aX).Position;local b6,au,al=X(Y)if ax.limitDistance and al>ax.maxDistance then au=false end;b5.Visible=au;if b5.Visible then b5.Position=b6;b5.Color=ax.textColor[1]b5.Transparency=ax.textColor[2]b5.Outline=ax.textOutline;b5.OutlineColor=ax.textOutlineColor;b5.Size=ax.textSize;b5.Font=ax.textFont;b5.Text=ax.text:gsub("{name}",aX.Name):gsub("{distance}",k(al)):gsub("{position}",tostring(Y))end end;local EspInterface={_hasLoaded=false,_objectCache={},_instanceCache={},whitelist={},maid=a.new(),sharedSettings={textSize=13,textFont=2,limitDistance=false,maxDistance=150},teamSettings={enemy={enabled=false,box=false,boxColor={Color3.new(1,0,0),1},boxOutline=true,boxOutlineColor={Color3.new(),1},boxFill=false,boxFillColor={Color3.new(1,0,0),0.5},healthBar=false,healthyColor=Color3.new(0,1,0),dyingColor=Color3.new(1,0,0),healthBarOutline=true,healthBarOutlineColor={Color3.new(),0.5},healthText=false,healthTextColor={Color3.new(1,1,1),1},healthTextOutline=true,healthTextOutlineColor=Color3.new(),box3d=false,box3dColor={Color3.new(1,0,0),1},name=false,nameColor={Color3.new(1,1,1),1},nameOutline=true,nameOutlineColor=Color3.new(),weapon=false,weaponColor={Color3.new(1,1,1),1},weaponOutline=true,weaponOutlineColor=Color3.new(),distance=false,distanceColor={Color3.new(1,1,1),1},distanceOutline=true,distanceOutlineColor=Color3.new(),tracer=false,tracerOrigin="Bottom",tracerColor={Color3.new(1,0,0),1},tracerOutline=true,tracerOutlineColor={Color3.new(),1},offScreenArrow=false,offScreenArrowColor={Color3.new(1,1,1),1},offScreenArrowSize=15,offScreenArrowRadius=150,offScreenArrowOutline=true,offScreenArrowOutlineColor={Color3.new(),1},chams=false,chamsVisibleOnly=false,chamsFillColor={Color3.new(0.2,0.2,0.2),0.5},chamsOutlineColor={Color3.new(1,0,0),0}},friendly={enabled=false,box=false,boxColor={Color3.new(0,1,0),1},boxOutline=true,boxOutlineColor={Color3.new(),1},boxFill=false,boxFillColor={Color3.new(0,1,0),0.5},healthBar=false,healthyColor=Color3.new(0,1,0),dyingColor=Color3.new(1,0,0),healthBarOutline=true,healthBarOutlineColor={Color3.new(),0.5},healthText=false,healthTextColor={Color3.new(1,1,1),1},healthTextOutline=true,healthTextOutlineColor=Color3.new(),box3d=false,box3dColor={Color3.new(0,1,0),1},name=false,nameColor={Color3.new(1,1,1),1},nameOutline=true,nameOutlineColor=Color3.new(),weapon=false,weaponColor={Color3.new(1,1,1),1},weaponOutline=true,weaponOutlineColor=Color3.new(),distance=false,distanceColor={Color3.new(1,1,1),1},distanceOutline=true,distanceOutlineColor=Color3.new(),tracer=false,tracerOrigin="Bottom",tracerColor={Color3.new(0,1,0),1},tracerOutline=true,tracerOutlineColor={Color3.new(),1},offScreenArrow=false,offScreenArrowColor={Color3.new(1,1,1),1},offScreenArrowSize=15,offScreenArrowRadius=150,offScreenArrowOutline=true,offScreenArrowOutlineColor={Color3.new(),1},chams=false,chamsVisibleOnly=false,chamsFillColor={Color3.new(0.2,0.2,0.2),0.5},chamsOutlineColor={Color3.new(0,1,0),0}}},instanceSettings={enabled=false,box=false,boxColor={Color3.new(1,1,0),1},boxOutline=true,boxOutlineColor={Color3.new(),1},boxFill=false,boxFillColor={Color3.new(1,1,0),0.5},healthBar=false,healthyColor=Color3.new(0,1,0),dyingColor=Color3.new(1,0,0),healthBarOutline=true,healthBarOutlineColor={Color3.new(),0.5},healthText=false,healthTextColor={Color3.new(1,1,1),1},healthTextOutline=true,healthTextOutlineColor=Color3.new(),box3d=false,box3dColor={Color3.new(1,1,0),1},name=false,nameColor={Color3.new(1,1,1),1},nameOutline=true,nameOutlineColor=Color3.new(),customText=false,customTextValue="",customTextColor={Color3.new(1,1,1),1},customTextOutline=true,customTextOutlineColor=Color3.new(),distance=false,distanceColor={Color3.new(1,1,1),1},distanceOutline=true,distanceOutlineColor=Color3.new(),tracer=false,tracerOrigin="Bottom",tracerColor={Color3.new(1,1,0),1},tracerOutline=true,tracerOutlineColor={Color3.new(),1},offScreenArrow=false,offScreenArrowColor={Color3.new(1,1,1),1},offScreenArrowSize=15,offScreenArrowRadius=150,offScreenArrowOutline=true,offScreenArrowOutlineColor={Color3.new(),1},chams=false,chamsVisibleOnly=false,chamsFillColor={Color3.new(0.2,0.2,0.2),0.5},chamsOutlineColor={Color3.new(1,1,0),0}}}function EspInterface.AddInstanceEsp(aX,aY)if not aX or not aX.Parent then warn("Cannot add ESP to invalid instance")return nil end;local am=EspInterface._instanceCache;if am[aX]then return am[aX]end;am[aX]=aW.new(aX,EspInterface,aY)return am[aX]end;function EspInterface.AddInstance(aX,ax)if not aX or not aX.Parent then warn("Cannot add ESP to invalid instance")return nil end;local am=EspInterface._instanceCache;if am[aX]then return am[aX]end;am[aX]=b4.new(aX,ax)return am[aX]end;function EspInterface.RemoveInstance(aX)local am=EspInterface._instanceCache;local b7=am[aX]if b7 then b7:Destruct()am[aX]=nil;return true end;return false end;function EspInterface.CleanupInstances()local am=EspInterface._instanceCache;local b8={}for aX,b7 in pairs(am)do if not aX or not aX.Parent then b8[#b8+1]=aX end end;for R=1,#b8 do local aX=b8[R]EspInterface.RemoveInstance(aX)end;return#b8 end;function EspInterface.AddInstances(b9,aY)local ba={}for R,aX in pairs(b9)do local bb=EspInterface.AddInstanceEsp(aX,aY)if bb then ba[R]=bb end end;return ba end;function EspInterface.AddInstancesByClass(bc,aY)local b9={}for R,bd in pairs(e:GetDescendants())do if bd:IsA(bc)then b9[#b9+1]=bd end end;return EspInterface.AddInstances(b9,aY)end;function EspInterface.Load()assert(not EspInterface._hasLoaded,"Esp has already been loaded.")local function be(a8)EspInterface._objectCache[a8]={a7.new(a8,EspInterface),aT.new(a8,EspInterface)}end;local function bf(a8)local b7=EspInterface._objectCache[a8]if b7 then for R=1,#b7 do b7[R]:Destruct()end;EspInterface._objectCache[a8]=nil end end;for ag,a8 in next,d:GetPlayers()do if a8~=f then be(a8)end end;EspInterface.playerAdded=d.PlayerAdded:Connect(be)EspInterface.playerRemoving=d.PlayerRemoving:Connect(bf)EspInterface.maid:AddTask(EspInterface.playerAdded)EspInterface.maid:AddTask(EspInterface.playerRemoving)EspInterface.cleanupConnection=c.Heartbeat:Connect(function()if tick()%10<0.1 then EspInterface.CleanupInstances()end end)EspInterface.maid:AddTask(EspInterface.cleanupConnection)EspInterface._hasLoaded=true end;function EspInterface.Unload()assert(EspInterface._hasLoaded,"Esp has not been loaded yet.")for a8,b7 in next,EspInterface._objectCache do if b7 then for R=1,#b7 do b7[R]:Destruct()end end end;o(EspInterface._objectCache)for aX,b7 in next,EspInterface._instanceCache do if b7 then b7:Destruct()end end;o(EspInterface._instanceCache)EspInterface.maid:Cleanup()EspInterface._hasLoaded=false end;function EspInterface.getWeapon(a8)local aV=a8.Character;if not aV then return"None"end;local bg=aV:FindFirstChildOfClass("Tool")if bg then return bg.Name end;return"Unarmed"end;function EspInterface.isFriendly(a8)return a8.Team and a8.Team==f.Team end;function EspInterface.getCharacter(a8)return a8.Character end;function EspInterface.getHealth(aV)local b0=aV and v(aV,"Humanoid")if b0 then return b0.Health,b0.MaxHealth end;return 100,100 end;function EspInterface.EnableEnemyEsp()EspInterface.teamSettings.enemy.enabled=true;EspInterface.teamSettings.enemy.box=true;EspInterface.teamSettings.enemy.name=true;EspInterface.teamSettings.enemy.distance=true;EspInterface.teamSettings.enemy.healthBar=true;EspInterface.teamSettings.enemy.weapon=true end;function EspInterface.EnableFriendlyEsp()EspInterface.teamSettings.friendly.enabled=true;EspInterface.teamSettings.friendly.box=true;EspInterface.teamSettings.friendly.name=true;EspInterface.teamSettings.friendly.distance=true;EspInterface.teamSettings.friendly.healthBar=true;EspInterface.teamSettings.friendly.weapon=true end;function EspInterface.EnableInstanceEsp()EspInterface.instanceSettings.enabled=true;EspInterface.instanceSettings.box=true;EspInterface.instanceSettings.name=true;EspInterface.instanceSettings.distance=true end;return EspInterface
